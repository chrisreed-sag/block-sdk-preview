/*
 * $Copyright (c) 2019 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 */
//*****************************************************************************
// Title:         TestHelpers
// Description:   EPL monitors and events used for testing blocks.
// Dependencies:  Analytics Builder
// Author:        CREE
//
//*****************************************************************************
package apamax.analyticsbuilder.test;

using apama.analyticsbuilder.ABConstants;
using apama.analyticsbuilder.Activation;
using apama.analyticsbuilder.BlockBase;
using apama.analyticsbuilder.RequestForwarding;

using apama.analyticsbuilder.CreateModel;
using apama.analyticsbuilder.BlockConfiguration;
using apama.analyticsbuilder.ModelState;
using apama.analyticsbuilder.Wire;

using apama.analyticsbuilder.BlockInfoRequest;
using apama.analyticsbuilder.BlockInfoResponse;

using com.apama.json.JSONPlugin;
using com.apama.exceptions.Exception;

/**
 * Request to create a test model.
 *
 * Sent by AnalyticsBuilderBaseTest.createTestModel pysys method.
 */
event Test {
	string blockUnderTest;
	string modelId;
	string jsonParams;
	string jsonInputs;
	dictionary<string, any> extraParams;
}

/**
 * Test Input.
 *
 * Returned by AnalyticsBuilderBaseTest.inputEvent pysys method.  Listened to by TestInput
 */
event Input {
	string inputId;
	string modelId;
	any value;
}

/**
 * Test Output.
 *
 * Sent by TestOutput and matches expressions from AnalyticsBuilderBaseTest.outputExpr pysys method.
 */
event Output {
	string outputId;
	string modelId;
	any value;
}

/** TestInput parameters */
event TestInput_$Parameters {
	/** Id of the test input this is connected to */
	string inputId;
	/** Type of the input */
	string type;
	constant string type_float := "float";
	constant string type_boolean := "boolean";
	constant string type_string := "string";
	constant string type_pulse := "pulse";
}

/** Test block for supplying input to a block under test */
event TestInput {
	BlockBase $base;
	TestInput_$Parameters $parameters;
	string modelId;
	action $init(dictionary<string, any> $modelScopeParameters) {
		modelId := $modelScopeParameters[ABConstants.MODEL_NAME_IDENTIFIER].valueToString();
		on all Input(inputId = $parameters.inputId, modelId = modelId) as i {
			$base.createTimer(0.1, i.value);
		}
	}
	action $timerTriggered(Activation $activation, any $payload) {
		log "TEST: Input "+modelId+"."+$parameters.inputId+" = "+$payload.valueToString() at INFO;
		$setOutput_output($activation, $payload);
	}
	action $outputType_output() returns string {
		return $parameters.type;
	}

	action<Activation, any> $setOutput_output;
}



/** TestOutput parameters */
event TestOutput_$Parameters {
	string outputId;
}
/** Test block for getting output from a block under test */
event TestOutput {
	BlockBase $base;
	TestOutput_$Parameters $parameters;
	string modelId;
	action $init(dictionary<string, any> $modelScopeParameters) {
		modelId := $modelScopeParameters[ABConstants.MODEL_NAME_IDENTIFIER].valueToString();
	}
	action $process(Activation $activation, any $input_input) {
		log "TEST: Output "+modelId+"."+$parameters.outputId+" = "+$input_input.valueToString() at INFO;
		emit Output($parameters.outputId, modelId, $input_input) to "TestOutput";
	}
}

/**
 * Model creation helper
 */
event ModelCreator {
	ModelState model;
	static action init(string modelId) returns ModelCreator {
		ModelCreator mc := new ModelCreator;
		mc.model.modelId := modelId;
		return mc;
	}
	action create() {
		CreateModel cm := new CreateModel;

		cm.state := model;

		route cm;
	}

	action wire(string sourceBlock, string sourceOutput, string targetBlock, string targetInput) {
		Wire a_b := new Wire;
		a_b.sourceBlockId := sourceBlock;
		a_b.sourceOutputName := sourceOutput;
		a_b.targetBlockId := targetBlock;
		a_b.targetInputName := targetInput;
		model.wires.append(a_b);
	}

	action block(string name, string type, any params) {
		BlockConfiguration block := new BlockConfiguration;
		block.type := type;
		string s;
		for s in params.getFieldNames() {
			block.parameters[s] := params.getEntry(s);
		}
		model.blocks[name] := block;
	}
}

/** Test helper.
 *
 * Creates models from Test requests, to test a block under test and connect to TestInput/ TestOutput blocks.
 */
monitor TestHelper {
	action onload() {
		on all Test() as t {
			// lookup block metadata:
			integer blockReq := integer.getUnique();
			string channel := "blockInfo-"+blockReq.toString();
			monitor.subscribe(channel);
			route BlockInfoRequest(blockReq, "EN", channel);
			on BlockInfoResponse(requestId = blockReq) as ir {
				monitor.unsubscribe(channel);
				string cat;
				for cat in ir.blocks.keys() {
					any block;
					for block in ir.blocks[cat] {
						if block.getEntry("id").valueToString() = t.blockUnderTest {
							try {
								createModel(t, block);
								return;
							} catch(Exception e) {
								log e.toStringWithStackTrace() at WARN;
							}
						}
					}
				}
				// failed to find block:
				log "Could not find block "+t.blockUnderTest at ERROR;
				if t.blockUnderTest.find(".") = -1 {
					log "Hint: have you remembered the package name of the block?" at INFO;
				}
			}
		}
		RequestForwarding.byKey(new Input, "modelId");
	}

	/** Create a model for the given block metadata. */
	action createModel(Test t, any block) {
		dictionary<any, any> params := <dictionary<any, any> > JSONPlugin.fromJSON(t.jsonParams);
		dictionary<any, any> inputs := <dictionary<any, any> > JSONPlugin.fromJSON(t.jsonInputs);
		ModelCreator c := ModelCreator.init(t.modelId);

		// create parameters from default or specified values:
		sequence<any> blockParams := <sequence<any> > block.getEntry("parameters");
		dictionary<string, any> paramValues:= {};
		any paramInfo;
		for paramInfo in blockParams {
			string name := <string> paramInfo.getEntry("id");
			if params.hasKey(name) {
				paramValues[name] := params[name];
			} else {
				if paramInfo.hasEntry("defaultValue") {
					paramValues[name] := paramInfo.getEntry("defaultValue");
				}
				// if not specified and not optional, the framework will log an error.
			}
		}
		c.block(t.blockUnderTest, t.blockUnderTest, paramValues);
		
		// create inputs, providing their type if specified (or not connected if specified as empty string):
		sequence<any> blockInputs := <sequence<any> > block.getEntry("inputs");
		any inputInfo;
		for inputInfo in blockInputs {
			string name := <string> inputInfo.getEntry("id");
			string specificType := "float"; // by default
			if inputs.hasKey(name) {
				ifpresent inputs[name] as inputType {
					specificType := inputType.valueToString();
				} else {
					specificType := "";
				}
			}
			if specificType = "" { continue; }
			string blockIn := "input_"+name;
			c.block(blockIn, TestInput.getName(), {"inputId":name, "type":specificType});
			c.wire(blockIn, "output", t.blockUnderTest, name);
		}

		// create outputs:
		sequence<any> blockOutputs := <sequence<any> > block.getEntry("outputs");
		any outputInfo;
		for outputInfo in blockOutputs {
			string name := <string> outputInfo.getEntry("id");
			string blockOut := "output_"+name;
			c.block(blockOut, TestOutput.getName(), {"outputId":name});
			c.wire(t.blockUnderTest, name, blockOut, "input");
		}
		c.create();
	}
}
		
